
--------------------------------------------------------------------------------
--- FILE: nest-cli.json ---
--------------------------------------------------------------------------------

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "assets": ["public"],
    "watchAssets": true
  }
}

--------------------------------------------------------------------------------
--- FILE: package.json ---
--------------------------------------------------------------------------------

{
  "name": "wholesalebd-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.908.0",
    "@aws-sdk/s3-request-presigner": "^3.908.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.1",
    "@nestjs/mongoose": "^11.0.3",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/swagger": "^11.2.0",
    "@nestjs/throttler": "^6.4.0",
    "@types/bcryptjs": "^3.0.0",
    "@types/multer": "^2.0.0",
    "@types/nodemailer": "^7.0.2",
    "@types/passport-jwt": "^4.0.1",
    "@types/qrcode": "^1.5.5",
    "@types/speakeasy": "^2.0.10",
    "@types/uuid": "^11.0.0",
    "bcryptjs": "^3.0.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "dotenv": "^17.2.3",
    "firebase-admin": "^13.5.0",
    "handlebars": "^4.7.8",
    "mongoose": "^8.19.1",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.9",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "qrcode": "^1.5.4",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "serverless-express": "^2.0.12",
    "speakeasy": "^2.0.0",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}


--------------------------------------------------------------------------------
--- FILE: tsconfig.build.json ---
--------------------------------------------------------------------------------

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


--------------------------------------------------------------------------------
--- FILE: tsconfig.json ---
--------------------------------------------------------------------------------

{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}


--------------------------------------------------------------------------------
--- FILE: vercel.json ---
--------------------------------------------------------------------------------

{
  "version": 2,
  "builds": [
    {
      "src": "src/main.ts",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/(.*)",
      "dest": "src/main.ts"
    }
  ]
}

--------------------------------------------------------------------------------
--- FILE: public/index.html ---
--------------------------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to the Wholesale BD API</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <style>
        :root {
            --primary-color: #2563eb; --secondary-color: #10b981; --tertiary-color: #f97316;
            --quaternary-color: #8b5cf6; --success-color: #22c55e; --error-color: #ef4444;
            --text-color-light: #f9fafb; --card-bg-color: rgba(255, 255, 255, 0.1);
            --border-radius: 12px; --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; min-height: 100vh; background-image: linear-gradient(135deg, #1e3a8a, #312e81);
            background-attachment: fixed; color: var(--text-color-light); display: flex; flex-direction: column;
            align-items: center; justify-content: center; padding: 2rem 0;
        }
        .container {
            max-width: 600px; width: 90%; margin: auto; padding: 2rem 1.5rem; background: var(--card-bg-color);
            backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.18); border-radius: var(--border-radius);
            box-shadow: var(--shadow); text-align: center;
        }
        .logo { margin: 0 auto 2rem auto; max-width: 250px; }
        .logo img { width: 100%; height: auto; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.4)); }
        h1 { font-size: clamp(1.8rem, 5vw, 2.5rem); margin-top: 0; margin-bottom: 1rem; }
        p { font-size: clamp(1rem, 2.5vw, 1.15rem); line-height: 1.6; margin-bottom: 2.5rem; opacity: 0.95; max-width: 500px; margin-left: auto; margin-right: auto; }
        .actions { display: flex; gap: 1rem; justify-content: center; flex-direction: column; }
        .btn { display: flex; align-items: center; justify-content: center; gap: 0.75rem; padding: 14px 28px; border-radius: var(--border-radius); text-decoration: none; font-size: 1rem; font-weight: 600; border: none; cursor: pointer; transition: all 0.3s ease; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn .icon { width: 20px; height: 20px; }
        .btn-primary { background-image: linear-gradient(45deg, #3b82f6 0%, #2563eb 100%); color: var(--text-color-light); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 7px 20px rgba(59, 130, 246, 0.4); }
        .btn-secondary { background-image: linear-gradient(45deg, #10b981 0%, #22c55e 100%); color: var(--text-color-light); }
        .btn-quaternary { background-image: linear-gradient(45deg, #a78bfa 0%, #8b5cf6 100%); color: var(--text-color-light); }

        .analytics-container {
            max-width: 700px; width: 90%; margin: 2rem auto 0 auto; padding: 1.5rem;
            background: var(--card-bg-color); backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: var(--border-radius); box-shadow: var(--shadow); display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;
        }
        .analytics-stat {
            background: rgba(0,0,0,0.15); padding: 1rem; border-radius: 8px; flex-grow: 1;
            min-width: 180px; display: flex; align-items: center; gap: 1rem;
        }
        .stat-icon { flex-shrink: 0; width: 40px; height: 40px; stroke-width: 1.5; color: var(--text-color-light); opacity: 0.8; }
        .stat-text .stat-value { font-size: 1.75rem; font-weight: 700; display: block; line-height: 1.2; }
        .stat-text .stat-label { font-size: 0.9rem; opacity: 0.8; display: block; }
        .hidden { display: none; }
        
        footer { width: 100%; text-align: center; font-size: 0.9rem; opacity: 0.8; padding: 2rem 1rem; margin-top: auto; }
        @media (min-width: 600px) { .actions { flex-direction: row; flex-wrap: wrap; } }
    </style>
</head>
<body>
    <main class="container">
        <a href="https://wholesale-bd-web-app.vercel.app" class="logo" title="Visit Wholesale BD Website">
            <img src="/logo.svg" alt="Wholesale BD Logo">
        </a>
        <h1>Welcome to the Wholesale BD Backend API</h1>
        <p>This is the engine powering Wholesale BD, Bangladesh's premier B2B wholesale platform. Explore our website or dive into the API documentation.</p>
        <div class="actions">
            <a href="https://wholesale-bd-web-app.vercel.app" class="btn btn-primary"><svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-4.5 4.5L21 3m0 0h-5.25M21 3v5.25" /></svg>Visit Website</a>
            <a href="/api" class="btn btn-secondary"><svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 12" /></svg>API Docs</a>
            <button id="show-analytics-btn" class="btn btn-quaternary">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z" /></svg>
                Show Highlights
            </button>
        </div>
    </main>

    <section id="analytics-section" class="analytics-container hidden">
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M18 18.72a9.094 9.094 0 0 0 3.741-.479 3 3 0 0 0-4.682-2.72m-7.5-2.962A3 3 0 0 1 3 18.72v-2.172c0-.923.63-1.724 1.52-1.962a7.5 7.5 0 0 1 1.52-1.962M12 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM12 10.5a3 3 0 1 1 6 0 3 3 0 0 1-6 0Z" /></svg>
            <div class="stat-text">
                <span id="total-users-count" class="stat-value">...</span>
                <span class="stat-label">Total Users</span>
            </div>
        </div>
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m21 7.5-9-5.25L3 7.5m18 0-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" /></svg>
            <div class="stat-text">
                <span id="total-products-count" class="stat-value">...</span>
                <span class="stat-label">Unique Products</span>
            </div>
        </div>
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg>
            <div class="stat-text">
                <span id="total-categories-count" class="stat-value">...</span>
                <span class="stat-label">Total Categories</span>
            </div>
        </div>
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" /></svg>
            <div class="stat-text">
                <span id="total-zones-count" class="stat-value">...</span>
                <span class="stat-label">Total Zones</span>
            </div>
        </div>
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 18.75a1.5 1.5 0 0 1-3 0m3 0a1.5 1.5 0 0 0-3 0m3 0h6m-9 0H3.375a1.125 1.125 0 0 1-1.125-1.125V14.25m17.25 4.5a1.5 1.5 0 0 1-3 0m3 0a1.5 1.5 0 0 0-3 0m3 0h1.125c.621 0 1.125-.504 1.125-1.125V14.25m-17.25 4.5v-1.875a3.375 3.375 0 0 1 3.375-3.375h9.75a3.375 3.375 0 0 1 3.375 3.375v1.875" /><path stroke-linecap="round" stroke-linejoin="round" d="M9 11.25l3-3m0 0l3 3m-3-3v7.5" /></svg>
            <div class="stat-text">
                <span id="total-orders-count" class="stat-value">...</span>
                <span class="stat-label">Total Orders</span>
            </div>
        </div>
        <div class="analytics-stat">
            <svg class="stat-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>
            <div class="stat-text">
                <span id="pending-orders-count" class="stat-value">...</span>
                <span class="stat-label">Pending Orders</span>
            </div>
        </div>
    </section>

    <footer><p>&copy; 2024 Wholesale BD &bull; All Rights Reserved</p></footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const showAnalyticsBtn = document.getElementById('show-analytics-btn');
            const analyticsSection = document.getElementById('analytics-section');
            
            const totalUsersSpan = document.getElementById('total-users-count');
            const totalProductsSpan = document.getElementById('total-products-count');
            const totalCategoriesSpan = document.getElementById('total-categories-count');
            const totalZonesSpan = document.getElementById('total-zones-count');
            const totalOrdersSpan = document.getElementById('total-orders-count');
            const pendingOrdersSpan = document.getElementById('pending-orders-count');

            async function fetchAnalyticsData() {
                try {
                    const [userResponse, productResponse, categoryResponse, zoneResponse, orderResponse] = await Promise.all([
                        fetch('/api/v1/users/count'),
                        fetch('/api/v1/products/count'),
                        fetch('/api/v1/categories/count'),
                        fetch('/api/v1/zones/count'),
                        fetch('/api/v1/orders/analytics')
                    ]);

                    if (!userResponse.ok || !productResponse.ok || !orderResponse.ok || !categoryResponse.ok || !zoneResponse.ok) {
                        throw new Error('Failed to fetch one or more analytics endpoints');
                    }

                    const userData = await userResponse.json();
                    const productData = await productResponse.json();
                    const categoryData = await categoryResponse.json();
                    const zoneData = await zoneResponse.json();
                    const orderData = await orderResponse.json();

                    totalUsersSpan.textContent = userData.totalUsers;
                    totalProductsSpan.textContent = productData.totalProducts;
                    totalCategoriesSpan.textContent = categoryData.totalCategories;
                    totalZonesSpan.textContent = zoneData.totalZones;
                    totalOrdersSpan.textContent = orderData.total;
                    pendingOrdersSpan.textContent = orderData.pending;

                } catch (error) {
                    console.error('Error fetching analytics:', error);
                    [totalUsersSpan, totalProductsSpan, totalCategoriesSpan, totalZonesSpan, totalOrdersSpan, pendingOrdersSpan]
                        .forEach(span => span.textContent = 'N/A');
                }
            }

            showAnalyticsBtn.addEventListener('click', () => {
                if (analyticsSection.classList.contains('hidden')) {
                    analyticsSection.classList.remove('hidden');
                }
                analyticsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            
            fetchAnalyticsData();
        });
    </script>
</body>
</html>

--------------------------------------------------------------------------------
--- FILE: public/swagger-custom.js ---
--------------------------------------------------------------------------------

// public/swagger-custom.js

function initializeSwaggerCustomizations() {
  try {
    const topbar = document.querySelector('.swagger-ui .topbar .topbar-wrapper');
    const infoContainer = document.querySelector('.swagger-ui .info');

    // Exit if the essential elements aren't ready yet
    if (!topbar || !infoContainer) {
      return;
    }

    // --- 1. SETUP TOP BAR BUTTONS ---
    if (!document.querySelector('.custom-btn-container')) {
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'custom-btn-container';

      // Re-introduce the "Home" button with text/emoji
      const homeButton = document.createElement('a');
      homeButton.href = '/';
      homeButton.target = '_self';
      homeButton.className = 'topbar-btn';
      homeButton.innerHTML = 'ðŸ  Home';
      buttonContainer.appendChild(homeButton);

      const backButton = document.createElement('button');
      backButton.className = 'topbar-btn';
      backButton.innerHTML = 'âª Back';
      backButton.onclick = () => history.back();
      buttonContainer.appendChild(backButton);

      const schemasButton = document.createElement('button');
      schemasButton.className = 'topbar-btn';
      schemasButton.innerHTML = 'ðŸ“œ Schemas';
      schemasButton.onclick = () => {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      };
      buttonContainer.appendChild(schemasButton);

      topbar.prepend(buttonContainer);
    }
    
    // --- 2. INJECT LOGO INTO INFO SECTION ---
    if (!document.getElementById('info-section-logo')) {
      const logoDiv = document.createElement('div');
      logoDiv.id = 'info-section-logo';
      // The div is empty; CSS will handle the background image.
      infoContainer.prepend(logoDiv);
    }

    // --- 3. "BACK TO TOP" BUTTON (Unchanged) ---
    if (!document.getElementById('back-to-top-btn')) {
      const backToTopButton = document.createElement('button');
      backToTopButton.id = 'back-to-top-btn';
      backToTopButton.innerHTML = 'â†‘';
      document.body.appendChild(backToTopButton);
      backToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
      window.addEventListener('scroll', () => {
        if (window.scrollY > 300) {
          backToTopButton.classList.add('show');
        } else {
          backToTopButton.classList.remove('show');
        }
      });
    }

  } catch (error) {
    console.error("Swagger custom script failed:", error);
  }
}

const observer = new MutationObserver((mutations, obs) => {
  const swaggerUI = document.getElementById('swagger-ui');
  if (swaggerUI && swaggerUI.children.length > 0) {
    initializeSwaggerCustomizations();
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});

--------------------------------------------------------------------------------
--- FILE: src/app.controller.ts ---
--------------------------------------------------------------------------------

// src/app.controller.ts

import {
  Controller,
  Get,
  ServiceUnavailableException,
  UseGuards, // +++ ADD THIS +++
} from '@nestjs/common';
import { AppService, HealthStatus, DbStats } from './app.service'; // +++ UPDATE THIS +++
import {
  ApiHeader, // +++ ADD THIS +++
  ApiOkResponse, // +++ ADD THIS +++
  ApiOperation,
  ApiResponse,
  ApiTags,
  ApiUnauthorizedResponse, // +++ ADD THIS +++
} from '@nestjs/swagger';
import { Throttle } from '@nestjs/throttler';
import { ApiKeyGuard } from './auth/guards/api-key.guard'; // +++ ADD THIS +++

@ApiTags('Health Check')
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  @ApiOperation({ summary: 'Default welcome endpoint for the API' })
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('status')
  @ApiOperation({ summary: 'Get the health status of the API and Database' })
  @ApiResponse({ status: 200, description: 'API and database are healthy.' })
  @ApiResponse({
    status: 503,
    description: 'Service is unavailable (e.g., database is down).',
  })
  @Throttle({ default: { limit: 10, ttl: 60000 } })
  getStatus(): HealthStatus {
    const healthStatus = this.appService.getStatus();

    if (healthStatus.dbStatus !== 'connected') {
      throw new ServiceUnavailableException(healthStatus);
    }

    return healthStatus;
  }

  // +++ ADD THIS NEW ENDPOINT +++
  @Get('db-stats')
  @ApiOperation({
    summary: 'Get document counts for all database collections (Protected)',
  })
  @ApiOkResponse({
    description: 'Returns a map of collection names to document counts.',
    schema: {
      example: {
        categories: 15,
        orders: 1500,
        products: 542,
        users: 125,
        zones: 8,
      },
    },
  })
  @ApiUnauthorizedResponse({ description: 'Invalid or missing API Key.' })
  @ApiHeader({
    name: 'x-api-key',
    description: 'The secret API key for access',
    required: true,
  })
  @UseGuards(ApiKeyGuard)
  async getDbStats(): Promise<DbStats> {
    return this.appService.getDbStats();
  }
}


--------------------------------------------------------------------------------
--- FILE: src/app.module.ts ---
--------------------------------------------------------------------------------

// src/app.module.ts

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { ThrottlerModule } from '@nestjs/throttler';
import { UsersModule } from './users/users.module';
import { ProductsModule } from './products/products.module';
import { OrdersModule } from './orders/orders.module';
import { CategoriesModule } from './categories/categories.module';
import { ZonesModule } from './zones/zones.module';
import { ApiKeyGuard } from './auth/guards/api-key.guard';
//import { SeederModule } from './seeder/seeder.module';
import { MetadataModule } from './metadata/metadata.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),

    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      // FIXED: Removed 'async' as it's not needed here
      useFactory: (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI'),
      }),
      inject: [ConfigService],
    }),

    ThrottlerModule.forRoot([
      {
        ttl: 60000,
        limit: 60,
      },
    ]),

    UsersModule,

    ProductsModule,

    OrdersModule,

    CategoriesModule,

    ZonesModule,

    MetadataModule,
  ],
  controllers: [AppController],
  providers: [AppService, ApiKeyGuard],
})
export class AppModule {}


--------------------------------------------------------------------------------
--- FILE: src/app.service.ts ---
--------------------------------------------------------------------------------

// src/app.service.ts

import { Injectable, ServiceUnavailableException } from '@nestjs/common'; // <-- UPDATE THIS IMPORT
import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';

export interface HealthStatus {
  apiStatus: 'ok';
  dbStatus: 'connected' | 'disconnected';
  timestamp: string;
}

export interface DbStats {
  [collectionName: string]: number;
}

@Injectable()
export class AppService {
  constructor(@InjectConnection() private readonly connection: Connection) {}

  getHello(): string {
    return 'Welcome to the Wholesale BD API!';
  }

  getStatus(): HealthStatus {
    const dbStatus =
      (this.connection.readyState as number) === 1
        ? 'connected'
        : 'disconnected';

    return {
      apiStatus: 'ok',
      dbStatus,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Retrieves statistics for all collections in the database.
   * @returns A promise that resolves to an object mapping collection names to their document counts.
   */
  async getDbStats(): Promise<DbStats> {
    // +++ FIX: Add a guard clause to ensure the DB connection is ready +++
    if (!this.connection.db) {
      throw new ServiceUnavailableException(
        'Database connection is not available.',
      );
    }

    const collections = await this.connection.db.collections();
    const stats: DbStats = {};

    await Promise.all(
      collections.map(async (collection) => {
        const count = await collection.countDocuments();
        stats[collection.collectionName] = count;
      }),
    );

    const sortedStats = Object.keys(stats)
      .sort()
      .reduce((obj, key) => {
        obj[key] = stats[key];
        return obj;
      }, {});

    return sortedStats;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/main.ts ---
--------------------------------------------------------------------------------

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import {
  SwaggerModule,
  DocumentBuilder,
  SwaggerCustomOptions,
} from '@nestjs/swagger';
// --- ADDED: Logger for consistent application logging ---
import { Logger, ValidationPipe } from '@nestjs/common';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';
// --- ADDED: Import the global exception filter ---
import { HttpExceptionFilter } from './common/filters/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  // --- ADDED: Instantiate the logger for bootstrap messages ---
  const logger = new Logger('Bootstrap');

  app.enableCors({
    origin:
      process.env.FRONTEND_URL || 'https://wholesale-bd-web-app.vercel.app',
    credentials: true,
  });

  app.setGlobalPrefix('api/v1');

  // --- ADDED: Register the global filter to catch all exceptions ---
  app.useGlobalFilters(new HttpExceptionFilter());

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  app.useStaticAssets(join(__dirname, '..', 'public'));

  const swaggerDocConfig = new DocumentBuilder()
    .setTitle(`Backend Api documentation`)
    .setDescription('The official API for the Wholesale BD B2B Platform.')
    .setVersion('1.0')
    .addTag('API Endpoints')
    .addBearerAuth()
    .addApiKey(
      { type: 'apiKey', name: 'x-api-key', in: 'header' },
      'ApiKeyAuth',
    )
    .build();
  const document = SwaggerModule.createDocument(app, swaggerDocConfig);

  const customSwaggerOptions: SwaggerCustomOptions = {
    customSiteTitle: `Wholesale BD API Docs`,
    customfavIcon: '/favicon.ico',
    customCssUrl:
      'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.11.0/swagger-ui.min.css',
    customJs: [
      'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.11.0/swagger-ui-bundle.js',
      'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.11.0/swagger-ui-standalone-preset.js',
      '/swagger-custom.js',
    ],
    customCss: `
      /* --- Top Bar Styles --- */
      .swagger-ui .topbar { 
        background-color: #1e3a8a; 
        height: 60px; /* Standard header height */
        padding: 0 20px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
      }
      .swagger-ui .topbar .topbar-wrapper {
         display: flex;
         align-items: center;
         width: 100%;
      }
      .swagger-ui .topbar a.link {
        display: none; /* Hide default Swagger logo */
      }
      .custom-btn-container {
        display: flex;
        align-items: center;
        width: 100%;
        gap: 15px;
      }
      
      /* Standard styles for our top bar buttons */
      .topbar-btn {
        display: inline-flex;
        align-items: center;
        text-decoration: none;
        color: white;
        background-color: rgba(255, 255, 255, 0.1);
        padding: 8px 14px;
        border-radius: 6px;
        font-size: 14px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      .topbar-btn:hover { background-color: rgba(255, 255, 255, 0.25); }
      .topbar-btn:active { transform: translateY(1px); }

      /* --- Info Section Logo Styles --- */
      #info-section-logo {
        width: 100%;
        max-width: 400px; /* Prevent it from being huge on very wide screens */
        height: 100px; /* A nice, tall height for the logo */
        margin-bottom: 20px; /* Space between logo and the title */

        /* Your full logo SVG, URL-encoded and embedded */
        background-image: url("data:image/svg+xml,%3csvg width='168' height='84' viewBox='0 0 6 3' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cdefs%3e%3clinearGradient id='logo-symbol-gradient' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3e%3cstop offset='0%25' stop-color='%2322C55E'/%3e%3cstop offset='100%25' stop-color='%2315803D'/%3e%3c/linearGradient%3e%3clinearGradient id='logo-text-gradient-flag' x1='0%25' y1='0%25' x2='100%25' y2='0%25'%3e%3cstop offset='0%25' stop-color='%23DC2626'/%3e%3cstop offset='100%25' stop-color='%23B91C1C'/%3e%3c/linearGradient%3e%3c/defs%3e%3cg%3e%3cg transform='translate(0.5, 1.5) scale(0.01)'%3e%3cpath d='M -50 -45 L 50 -50 L 45 50 L -45 40 Z' fill='url(%23logo-symbol-gradient)'/%3e%3cpath d='M -30 -47 A 35 35 0 0 1 30 -48' fill='none' stroke='%2316A34A' stroke-width='8' stroke-linecap='round'/%3e%3c/g%3e%3ctext x='0.5' y='1.5' font-family='Poppins, sans-serif' font-size='0.8' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3eW%3c/text%3e%3c/g%3e%3ctext x='1.2' y='1.5' fill='url(%23logo-text-gradient-flag)' font-family='Poppins, sans-serif' font-size='0.65' font-weight='bold' dominant-baseline='middle'%3eWholesale BD%3c/text%3e%3c/svg%3e");
        
        background-size: contain;
        background-repeat: no-repeat;
        background-position: left center; /* Align logo to the left */
      }

      /* Responsive styles for logo */
      @media (max-width: 768px) {
        #info-section-logo {
          max-width: 300px;
          height: 75px;
        }
      }

      /* "Back to Top" Button Styles (Unchanged) */
      #back-to-top-btn {
        position: fixed; bottom: 25px; right: 25px; z-index: 1000;
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, transform 0.2s ease;
        width: 45px; height: 45px; border-radius: 50%;
        background-image: linear-gradient(45deg, #3b82f6 0%, #2563eb 100%);
        color: white; border: none; cursor: pointer; font-size: 24px;
        line-height: 45px; text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }
      #back-to-top-btn.show { opacity: 1; visibility: visible; }
      #back-to-top-btn:hover { transform: translateY(-3px); box-shadow: 0 6px 15px rgba(0, 0, 0, 0.35); }
    `,
  };

  // --- CHANGED: Use 'docs' as the path for consistency with other logs ---
  SwaggerModule.setup('api', app, document, customSwaggerOptions);

  if (!process.env.VERCEL) {
    const port = process.env.PORT || 3001;
    await app.listen(port);
    // --- CHANGED: Using logger instead of console.log ---
    logger.log(`ðŸš€ Local server running on: http://localhost:${port}`);
    logger.log(`ðŸŒ Public index page at: http://localhost:${port}/`);
    logger.log(`ðŸ“š Swagger docs at: http://localhost:${port}/api`);
  } else {
    await app.init();
  }

  return app.getHttpAdapter().getInstance();
}

export default bootstrap();


--------------------------------------------------------------------------------
--- FILE: src/auth/guards/api-key.guard.ts ---
--------------------------------------------------------------------------------

import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
// We no longer need to import Request from 'express', avoiding the conflict.

@Injectable()
export class ApiKeyGuard implements CanActivate {
  constructor(private configService: ConfigService) {}

  canActivate(context: ExecutionContext): boolean {
    // FIXED: We explicitly define the type of 'request' with the 'headers' property we need.
    const request: { headers: { [key: string]: string } } = context
      .switchToHttp()
      .getRequest();

    const apiKey = request.headers['x-api-key'];

    const validApiKey = this.configService.getOrThrow<string>('API_KEY');

    if (apiKey !== validApiKey) {
      throw new UnauthorizedException('Invalid or missing API Key');
    }

    return true;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/categories/categories.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get } from '@nestjs/common';
import { ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import { CategoriesService } from './categories.service';
import { CategoryResponseDto } from './dto/category-response.dto';

@ApiTags('Categories')
@Controller('categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) {}

  @Get('count')
  @ApiOperation({ summary: 'Get the total number of categories' })
  @ApiOkResponse({
    description: 'Returns the total count of categories.',
    schema: { example: { totalCategories: 15 } },
  })
  async getCategoryCount(): Promise<{ totalCategories: number }> {
    const count = await this.categoriesService.countAll();
    return { totalCategories: count };
  }

  @Get()
  @ApiOperation({ summary: 'Get a list of all categories' })
  @ApiOkResponse({
    description: 'An array of category records, sorted by sortOrder.',
    type: [CategoryResponseDto],
  })
  async findAll(): Promise<CategoryResponseDto[]> {
    const categories = await this.categoriesService.findAll();
    return categories.map((cat) =>
      CategoryResponseDto.fromCategoryDocument(cat),
    );
  }
}


--------------------------------------------------------------------------------
--- FILE: src/categories/categories.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CategoriesController } from './categories.controller';
import { CategoriesService } from './categories.service';
import { Category, CategorySchema } from './schemas/category.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Category.name, schema: CategorySchema },
    ]),
  ],
  controllers: [CategoriesController],
  providers: [CategoriesService],
})
export class CategoriesModule {}


--------------------------------------------------------------------------------
--- FILE: src/categories/categories.service.ts ---
--------------------------------------------------------------------------------

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Category, CategoryDocument } from './schemas/category.schema';

@Injectable()
export class CategoriesService {
  constructor(
    @InjectModel(Category.name) private categoryModel: Model<CategoryDocument>,
  ) {}

  async findAll(): Promise<CategoryDocument[]> {
    return this.categoryModel.find().sort({ sortOrder: 1 }).exec();
  }

  // --- ADD THIS NEW METHOD ---
  async countAll(): Promise<number> {
    return this.categoryModel.countDocuments().exec();
  }
}


--------------------------------------------------------------------------------
--- FILE: src/categories/dto/category-response.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { CategoryDocument } from '../schemas/category.schema';

export class CategoryResponseDto {
  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a47',
    description: 'Unique identifier for the category.',
  })
  _id: string;

  @ApiProperty({
    example: 'Electronics',
    description: 'The name of the category.',
  })
  name: string;

  @ApiProperty({
    required: false,
    example: 'Gadgets and electronic devices.',
    description: 'A brief description of the category.',
  })
  description?: string;

  @ApiProperty({
    example: true,
    description: 'Indicates if the category is currently active and visible.',
  })
  isActive: boolean;

  @ApiProperty({
    example: 1,
    description: 'The order in which the category should be displayed.',
  })
  sortOrder: number;

  static fromCategoryDocument(
    categoryDoc: CategoryDocument,
  ): CategoryResponseDto {
    const dto = new CategoryResponseDto();
    dto._id = categoryDoc._id.toString();
    dto.name = categoryDoc.name;
    dto.description = categoryDoc.description;
    dto.isActive = categoryDoc.isActive;
    dto.sortOrder = categoryDoc.sortOrder;
    return dto;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/categories/schemas/category.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';

export type CategoryDocument = HydratedDocument<Category>;

@Schema({ timestamps: true })
export class Category {
  @Prop({ required: true, unique: true, trim: true })
  name: string;

  @Prop({ trim: true })
  description?: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: 0 })
  sortOrder: number;
  // Add this inside the Category class
  // For TypeScript awareness of Mongoose's timestamps
  createdAt: Date;
  updatedAt: Date;
}

export const CategorySchema = SchemaFactory.createForClass(Category);


--------------------------------------------------------------------------------
--- FILE: src/common/filters/http-exception.filter.ts ---
--------------------------------------------------------------------------------

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : { message: 'Internal server error' };

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      ...(typeof message === 'object' ? message : { message }),
    };

    // Log the full error for debugging, especially for 500-level errors
    if (status >= 500) {
      this.logger.error(
        `[${request.method}] ${request.url} - Status: ${status}`,
        exception instanceof Error
          ? exception.stack
          : JSON.stringify(exception),
      );
    } else {
      // For client errors (4xx), a simple warning is often sufficient
      this.logger.warn(
        `[${request.method}] ${request.url} - Status: ${status} - Message: ${JSON.stringify(
          message,
        )}`,
      );
    }

    response.status(status).json(errorResponse);
  }
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/admin-metadata.controller.ts ---
--------------------------------------------------------------------------------

import {
  Controller,
  Get,
  Param,
  Put,
  Body,
  UseGuards,
  Query,
  ParseIntPipe,
  DefaultValuePipe,
  Post,
  Delete,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiKeyGuard } from '../auth/guards/api-key.guard';
import { MetadataService } from './metadata.service';
import {
  ApiHeader,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiResponse,
  ApiTags,
} from '@nestjs/swagger';
import { UpdateMetadataDto } from './dto/update-metadata.dto';
import { LanguageDto } from './dto/language.dto';
import { SetDefaultLanguageDto } from './dto/set-default-language.dto';

@ApiTags('Metadata (Admin)')
@Controller('admin/metadata')
@UseGuards(ApiKeyGuard)
@ApiHeader({
  name: 'x-api-key',
  required: true,
  description: 'The secret API key for admin access.',
})
export class AdminMetadataController {
  constructor(private readonly metadataService: MetadataService) {}

  @Post('/seed')
  @ApiOperation({
    summary: 'Seed the database with initial data',
    description:
      'Populates the metadata collection with default documents (globalConfig, layoutConfig, etc.). This endpoint will fail if any data already exists in the collection, preventing accidental overwrites.',
  })
  @ApiResponse({
    status: 201,
    description: 'Database seeded successfully.',
  })
  @ApiResponse({
    status: 409,
    description: 'Conflict. Database is not empty.',
  })
  seedDatabase() {
    return this.metadataService.seedDatabase();
  }

  @Get()
  @ApiOperation({
    summary: 'List all metadata keys (Paginated)',
    description:
      'Provides a paginated list of all metadata keys for the admin panel. The full `value` is not returned for performance; use the GET /:key endpoint to fetch the full data for editing.',
  })
  @ApiQuery({
    name: 'page',
    description: 'Page number for pagination.',
    example: 1,
    required: false,
  })
  @ApiQuery({
    name: 'limit',
    description: 'Number of items per page.',
    example: 20,
    required: false,
  })
  @ApiQuery({
    name: 'search',
    description: 'Filter keys by a search term (case-insensitive).',
    example: 'pageMeta',
    required: false,
  })
  findAll(
    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,
    @Query('search') search?: string,
  ) {
    return this.metadataService.findAllPaginated(page, limit, search);
  }

  @Get(':key')
  @ApiOperation({
    summary: 'Get a single metadata document for editing',
    description:
      'Fetches a single, complete metadata document with all its language variants, suitable for populating an admin editing form.',
  })
  @ApiParam({
    name: 'key',
    description:
      'The full key of the document to fetch, including `draft:` prefix if applicable.',
    example: 'globalConfig',
  })
  findOne(@Param('key') key: string) {
    return this.metadataService.findAdminByKey(key);
  }

  @Put(':key')
  @ApiOperation({
    summary: 'Update or create a metadata document',
    description:
      'Saves changes to a metadata document. If the key does not exist, it will be created. This is the primary endpoint for saving content from the admin panel. To work on changes without affecting the live site, use a `draft:` prefix on your key (e.g., `draft:layoutConfig`).',
  })
  @ApiParam({
    name: 'key',
    description: 'The key of the document to save.',
    example: 'draft:layoutConfig',
  })
  update(@Param('key') key: string, @Body() updateDto: UpdateMetadataDto) {
    return this.metadataService.update(key, updateDto);
  }

  @Post('/publish/:draftKey')
  @ApiOperation({
    summary: 'Publish a draft to the live site',
    description:
      'Copies the content from a draft document (e.g., `draft:layoutConfig`) to its corresponding live document (`layoutConfig`) and then deletes the draft. This is the action for making staged changes visible to the public.',
  })
  @ApiParam({
    name: 'draftKey',
    description: 'The full key of the draft to publish.',
    example: 'draft:layoutConfig',
  })
  @HttpCode(HttpStatus.OK)
  publishDraft(@Param('draftKey') draftKey: string) {
    return this.metadataService.publishDraft(draftKey);
  }

  @Get('config/languages')
  @ApiOperation({
    summary: 'Get the list of available languages',
    description:
      'Retrieves the `availableLanguages` array from the `globalConfig` document.',
  })
  getLanguages() {
    return this.metadataService.getLanguages();
  }

  @Post('config/languages')
  @ApiOperation({
    summary: 'Add a new language to the system',
    description:
      'Adds a new language to `globalConfig` and then traverses all other metadata documents to add a placeholder value for the new language code in every multilingual text field.',
  })
  @ApiResponse({ status: 201, description: 'Language added successfully.' })
  addLanguage(@Body() languageDto: LanguageDto) {
    return this.metadataService.addLanguage(languageDto);
  }

  @Delete('config/languages/:code')
  @ApiOperation({
    summary: 'Remove a language from the system (Destructive)',
    description:
      'Removes a language from `globalConfig` and deletes its corresponding key from every multilingual text field in all other metadata documents. This action cannot be undone. The default language cannot be deleted.',
  })
  @ApiParam({
    name: 'code',
    description: 'The language code to delete.',
    example: 'es-ES',
  })
  @HttpCode(HttpStatus.NO_CONTENT)
  removeLanguage(@Param('code') code: string) {
    return this.metadataService.removeLanguage(code);
  }

  @Put('config/default-language')
  @ApiOperation({
    summary: 'Set the default language',
    description:
      'Updates the `defaultLanguage` property in the `globalConfig` document.',
  })
  setDefaultLanguage(@Body() dto: SetDefaultLanguageDto) {
    return this.metadataService.setDefaultLanguage(dto.code);
  }
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/metadata.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MetadataService } from './metadata.service';
import { Metadata, MetadataSchema } from './schemas/metadata.schema';
import { PublicMetadataController } from './public-metadata.controller';
import { AdminMetadataController } from './admin-metadata.controller';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Metadata.name, schema: MetadataSchema },
    ]),
  ],
  controllers: [PublicMetadataController, AdminMetadataController],
  providers: [MetadataService],
})
export class MetadataModule {}


--------------------------------------------------------------------------------
--- FILE: src/metadata/metadata.service.ts ---
--------------------------------------------------------------------------------

import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Metadata, MetadataDocument } from './schemas/metadata.schema';
import { LanguageDto } from './dto/language.dto';
import { UpdateMetadataDto } from './dto/update-metadata.dto';
import { IGlobalConfigValue } from './types/metadata.types';
import { SEED_DATA } from './data/seed-data';

@Injectable()
export class MetadataService {
  private readonly logger = new Logger(MetadataService.name);

  constructor(
    @InjectModel(Metadata.name) private metadataModel: Model<MetadataDocument>,
  ) {}

  // --- PUBLIC METHODS ---

  async findByKey(key: string): Promise<MetadataDocument> {
    if (key.startsWith('draft:')) {
      throw new BadRequestException(
        'Cannot fetch draft keys via the public endpoint.',
      );
    }
    const doc = await this.metadataModel.findOne({ key }).lean().exec();
    if (!doc) {
      throw new NotFoundException(`Metadata with key "${key}" not found`);
    }
    return doc as MetadataDocument;
  }

  // --- ADMIN METHODS ---

  async findAllPaginated(page: number, limit: number, search?: string) {
    const query = search ? { key: { $regex: search, $options: 'i' } } : {};
    const skip = (page - 1) * limit;

    const [results, total] = await Promise.all([
      this.metadataModel
        .find(query, { key: 1, description: 1, updatedAt: 1 })
        .sort({ key: 1 })
        .skip(skip)
        .limit(limit)
        .lean()
        .exec(),
      this.metadataModel.countDocuments(query),
    ]);

    return { data: results, total, page, lastPage: Math.ceil(total / limit) };
  }

  async findAdminByKey(key: string): Promise<MetadataDocument> {
    const doc = await this.metadataModel.findOne({ key }).lean().exec();
    if (!doc) {
      throw new NotFoundException(`Metadata with key "${key}" not found`);
    }
    return doc as MetadataDocument;
  }

  async update(key: string, dto: UpdateMetadataDto): Promise<MetadataDocument> {
    return this.metadataModel
      .findOneAndUpdate(
        { key },
        { $set: { value: dto.value, description: dto.description } },
        { new: true, upsert: true },
      )
      .exec();
  }

  async publishDraft(
    draftKey: string,
  ): Promise<{ message: string; liveKey: string }> {
    if (!draftKey.startsWith('draft:')) {
      throw new BadRequestException(
        'The provided key is not a valid draft key.',
      );
    }
    const liveKey = draftKey.replace('draft:', '');
    this.logger.log(
      `Publishing draft '${draftKey}' to live key '${liveKey}'...`,
    );

    const draftDoc = await this.findAdminByKey(draftKey);

    await this.update(liveKey, {
      value: draftDoc.value,
      description: draftDoc.description,
    });
    await this.metadataModel.deleteOne({ key: draftKey }).exec();

    this.logger.log(`Successfully published '${liveKey}' and removed draft.`);
    return { message: `Successfully published draft to '${liveKey}'`, liveKey };
  }

  async seedDatabase(): Promise<{ message: string; count: number }> {
    const count = await this.metadataModel.countDocuments().exec();
    if (count > 0) {
      throw new ConflictException(
        'Database is not empty. Seeding is only allowed on a fresh database.',
      );
    }

    this.logger.log(`Seeding database with ${SEED_DATA.length} documents...`);
    await this.metadataModel.insertMany(SEED_DATA);
    this.logger.log('Database seeding complete.');

    return {
      message: 'Database seeded successfully.',
      count: SEED_DATA.length,
    };
  }

  // --- LANGUAGE MANAGEMENT ---

  private async getGlobalConfig(): Promise<{
    doc: MetadataDocument;
    value: IGlobalConfigValue;
  }> {
    const doc = await this.findAdminByKey('globalConfig');
    return { doc, value: doc.value as unknown as IGlobalConfigValue };
  }

  async getLanguages(): Promise<IGlobalConfigValue['availableLanguages']> {
    const { value } = await this.getGlobalConfig();
    return value.availableLanguages || [];
  }

  async setDefaultLanguage(code: string): Promise<MetadataDocument> {
    const { doc, value } = await this.getGlobalConfig();
    if (!value.availableLanguages.find((lang) => lang.code === code)) {
      throw new BadRequestException(
        `Language code "${code}" is not available.`,
      );
    }
    value.defaultLanguage = code;
    return this.update('globalConfig', {
      // --- THE FIX ---
      value: value as unknown as Record<string, unknown>,
      description: doc.description,
    });
  }

  async addLanguage(dto: LanguageDto): Promise<void> {
    this.logger.log(`Adding new language: ${dto.code} (${dto.name})`);
    const { doc, value } = await this.getGlobalConfig();

    if (value.availableLanguages.find((lang) => lang.code === dto.code)) {
      throw new ConflictException(
        `Language code "${dto.code}" already exists.`,
      );
    }
    value.availableLanguages.push(dto);
    const langCodes = value.availableLanguages.map((l) => l.code);

    await this.update('globalConfig', {
      // --- THE FIX ---
      value: value as unknown as Record<string, unknown>,
      description: doc.description,
    });

    await this.traverseAndUpdateAllDocuments((obj) => {
      if (this.isLanguageObject(obj, langCodes)) {
        obj[dto.code] = `[NEEDS TRANSLATION: ${dto.name}]`;
      }
    });
    this.logger.log(`Finished propagating language ${dto.code}.`);
  }

  async removeLanguage(code: string): Promise<void> {
    this.logger.warn(`Removing language: ${code}`);
    const { doc, value } = await this.getGlobalConfig();

    if (value.defaultLanguage === code) {
      throw new BadRequestException('Cannot remove the default language.');
    }
    const initialLength = value.availableLanguages.length;
    value.availableLanguages = value.availableLanguages.filter(
      (lang) => lang.code !== code,
    );
    if (initialLength === value.availableLanguages.length) {
      throw new NotFoundException(`Language code "${code}" not found.`);
    }

    await this.update('globalConfig', {
      // --- THE FIX ---
      value: value as unknown as Record<string, unknown>,
      description: doc.description,
    });

    const langCodes = value.availableLanguages.map((l) => l.code);
    await this.traverseAndUpdateAllDocuments((obj) => {
      if (this.isLanguageObject(obj, langCodes)) {
        delete obj[code];
      }
    });
    this.logger.log(`Finished removing language ${code}.`);
  }

  // --- HELPERS ---

  private isLanguageObject(
    obj: unknown,
    langCodes: string[],
  ): obj is Record<string, unknown> {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return false;
    }
    const keys = Object.keys(obj);
    if (keys.length === 0) return false;
    return keys.some((key) => langCodes.includes(key));
  }

  private async traverseAndUpdateAllDocuments(
    updateFn: (obj: Record<string, unknown>) => void,
  ) {
    const cursor = this.metadataModel.find({}).cursor();
    for (
      let doc = await cursor.next();
      doc != null;
      doc = await cursor.next()
    ) {
      this.recursiveApply(doc.value, updateFn);
      doc.markModified('value');
      await doc.save();
    }
  }

  private recursiveApply(
    obj: unknown,
    updateFn: (obj: Record<string, unknown>) => void,
  ) {
    if (typeof obj !== 'object' || obj === null) return;
    const currentObj = obj as Record<string, unknown>;
    updateFn(currentObj);

    for (const key in currentObj) {
      if (Object.prototype.hasOwnProperty.call(currentObj, key)) {
        this.recursiveApply(currentObj[key], updateFn);
      }
    }
  }
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/public-metadata.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get, Param, Query, Res, Logger } from '@nestjs/common';
import {
  ApiOkResponse,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiTags,
} from '@nestjs/swagger';
import { Response } from 'express';
import { MetadataService } from './metadata.service';
import { IGlobalConfigValue } from './types/metadata.types';
import { MetadataDocument } from './schemas/metadata.schema';

// Helper function with its own logger instance
const logger = new Logger('LanguageFilter');

const isMultilingualObject = (obj: unknown): obj is Record<string, unknown> => {
  if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
    return false;
  }
  const keys = Object.keys(obj);
  return keys.length > 0 && keys.every((k) => k.match(/^[a-z]{2}-[A-Z]{2}$/));
};

/**
 * Type-safe recursive function to filter data by language.
 * It accepts and returns `unknown` because the transformation changes the data's shape.
 */
const filterByLang = (
  data: unknown,
  lang: string,
  defaultLang: string,
): unknown => {
  if (isMultilingualObject(data)) {
    if (data[lang]) {
      return data[lang];
    }
    if (data[defaultLang]) {
      // Logic Warning: Log when a fallback occurs.
      logger.warn(
        `Translation for lang '${lang}' not found. Falling back to default '${defaultLang}'.`,
      );
      return data[defaultLang];
    }
    // Fallback to the very first available translation if even the default is missing
    return Object.values(data)[0];
  }

  if (Array.isArray(data)) {
    return data.map((item) => filterByLang(item, lang, defaultLang));
  }

  if (typeof data === 'object' && data !== null) {
    // Cast to Record<string, unknown> to safely iterate over keys
    const currentObject = data as Record<string, unknown>;
    const newObj: Record<string, unknown> = {};
    for (const key in currentObject) {
      newObj[key] = filterByLang(currentObject[key], lang, defaultLang);
    }
    return newObj;
  }

  return data;
};

// Define a clear return type for our controller method's successful response
type PublicMetadataResponse = {
  key: string;
  value: unknown;
  updatedAt: Date;
};

@ApiTags('Metadata (Public)')
@Controller('metadata')
export class PublicMetadataController {
  constructor(private readonly metadataService: MetadataService) {}

  @Get(':key')
  @ApiOperation({
    summary: 'Get a metadata document by key',
    description:
      'This is the primary public endpoint for fetching front-end configuration. It is highly optimized for speed and caching. It will automatically filter content to a single language if the `lang` query parameter is provided.',
  })
  @ApiParam({
    name: 'key',
    description: 'The key of the metadata document to retrieve.',
    example: 'layoutConfig',
  })
  @ApiQuery({
    name: 'lang',
    required: false,
    description:
      'Language code to filter content (e.g., bn-BD). If omitted, the full multilingual object is returned.',
    example: 'bn-BD',
  })
  @ApiOkResponse({
    description:
      'Returns the requested metadata document, potentially filtered by language.',
  })
  // FIX #1: Added an explicit Promise return type. This resolves the `no-unsafe-assignment` error
  // by clearly defining the expected output on success, satisfying the linter.
  async findOne(
    @Param('key') key: string,
    @Query('lang') lang: string,
    @Res({ passthrough: true }) res: Response,
  ): Promise<PublicMetadataResponse> {
    // The useless try/catch block has been removed.
    const document: MetadataDocument =
      await this.metadataService.findByKey(key);

    let responseValue: unknown = document.value;

    if (lang) {
      const globalConfigDoc =
        await this.metadataService.findByKey('globalConfig');
      // FIX #2: Use the recommended `as unknown as Type` cast. This is the safe way to
      // tell TypeScript you're certain about a type conversion that it can't verify itself.
      // This resolves the compiler error 2352.
      const globalConfig =
        globalConfigDoc.value as unknown as IGlobalConfigValue;
      const defaultLang = globalConfig.defaultLanguage || 'en-US';
      responseValue = filterByLang(document.value, lang, defaultLang);
    }

    res.setHeader(
      'Cache-Control',
      'public, s-maxage=300, stale-while-revalidate=3600',
    );

    return {
      key: document.key,
      value: responseValue,
      updatedAt: document.updatedAt,
    };
  }
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/data/seed-data.ts ---
--------------------------------------------------------------------------------

/**
 * The initial data to seed the database with.
 * This ensures the application has a valid starting configuration.
 */
export const SEED_DATA = [
  {
    key: 'globalConfig',
    description: 'Global site configuration, cached long-term on clients.',
    value: {
      siteName: 'Wholesale BD',
      defaultLanguage: 'en-US',
      availableLanguages: [
        { code: 'en-US', name: 'English' },
        { code: 'bn-BD', name: 'à¦¬à¦¾à¦‚à¦²à¦¾' },
        { code: 'es-ES', name: 'EspaÃ±ol' },
      ],
      brand: {
        officialName: 'Wholesale Bangladesh Ltd.',
        tagline: {
          'en-US': {
            sm: 'B2B Wholesale Platform',
            md: 'The Premier B2B Wholesale Platform',
            lg: 'The Premier B2B Wholesale Platform in Bangladesh',
          },
          'bn-BD': {
            sm: 'B2B à¦ªà¦¾à¦‡à¦•à¦¾à¦°à¦¿ à¦ªà§à¦²à§à¦¯à¦¾à¦Ÿà¦«à¦°à§à¦®',
            md: 'à¦ªà§à¦°à¦¿à¦®à¦¿à¦¯à¦¼à¦¾à¦° B2B à¦ªà¦¾à¦‡à¦•à¦¾à¦°à¦¿ à¦ªà§à¦²à§à¦¯à¦¾à¦Ÿà¦«à¦°à§à¦®',
            lg: 'à¦¬à¦¾à¦‚à¦²à¦¾à¦¦à§‡à¦¶à§‡à¦° à¦ªà§à¦°à¦¿à¦®à¦¿à¦¯à¦¼à¦¾à¦° B2B à¦ªà¦¾à¦‡à¦•à¦¾à¦°à¦¿ à¦ªà§à¦²à§à¦¯à¦¾à¦Ÿà¦«à¦°à§à¦®',
          },
        },
        logos: [
          {
            useCase: 'Primary Logo Light',
            path: '/assets/logos/logo-light.svg',
            alt: {
              'en-US': 'Wholesale BD Official Logo',
              'bn-BD': 'à¦¹à§‹à¦²à¦¸à§‡à¦² à¦¬à¦¿à¦¡à¦¿ à¦…à¦«à¦¿à¦¸à¦¿à¦¯à¦¼à¦¾à¦² à¦²à§‹à¦—à§‹',
            },
          },
          {
            useCase: 'Favicon',
            path: '/favicon.ico',
            alt: {
              'en-US': 'Wholesale BD Icon',
              'bn-BD': 'à¦¹à§‹à¦²à¦¸à§‡à¦² à¦¬à¦¿à¦¡à¦¿ à¦†à¦‡à¦•à¦¨',
            },
          },
        ],
      },
    },
  },
  {
    key: 'layoutConfig',
    description: 'Data for the main UI layout, cached long-term on clients.',
    value: {
      navigation: {
        headerNav: [
          {
            id: 'nav-home',
            path: '/',
            label: { 'en-US': 'Home', 'bn-BD': 'à¦¹à§‹à¦®' },
            icon: 'Home',
          },
        ],
        footerLinkGroups: [
          {
            title: { 'en-US': 'Company', 'bn-BD': 'à¦•à§‹à¦®à§à¦ªà¦¾à¦¨à¦¿' },
            links: [
              {
                id: 'footer-about',
                path: '/about',
                label: {
                  'en-US': { lg: 'About Us', md: 'About', sm: 'â„¹ï¸' },
                  'bn-BD': {
                    lg: 'à¦†à¦®à¦¾à¦¦à§‡à¦° à¦¸à¦®à§à¦ªà¦°à§à¦•à§‡',
                    md: 'à¦¸à¦®à§à¦ªà¦°à§à¦•à§‡',
                    sm: 'â„¹ï¸',
                  },
                },
              },
            ],
          },
        ],
      },
      footer: {
        description: {
          'en-US': {
            sm: 'Your B2B destination.',
            lg: 'Your one-stop destination for bulk purchasing and seamless B2B connections across Bangladesh.',
          },
          'bn-BD': {
            sm: 'à¦†à¦ªà¦¨à¦¾à¦° B2B à¦—à¦¨à§à¦¤à¦¬à§à¦¯à¥¤',
            lg: 'à¦¬à¦¾à¦‚à¦²à¦¾à¦¦à§‡à¦¶ à¦œà§à¦¡à¦¼à§‡ à¦¬à¦¾à¦²à§à¦• à¦•à§à¦°à¦¯à¦¼ à¦à¦¬à¦‚ à¦¨à¦¿à¦°à§à¦¬à¦¿à¦˜à§à¦¨ B2B à¦¸à¦‚à¦¯à§‹à¦—à§‡à¦° à¦œà¦¨à§à¦¯ à¦†à¦ªà¦¨à¦¾à¦° à¦“à¦¯à¦¼à¦¾à¦¨-à¦¸à§à¦Ÿà¦ª à¦—à¦¨à§à¦¤à¦¬à§à¦¯à¥¤',
          },
        },
        socialLinks: [
          {
            platform: 'Facebook',
            url: 'https://facebook.com/wholesalebd',
            icon: 'Facebook',
          },
        ],
        copyright: {
          'en-US': 'Â© {currentYear} Wholesale BD Ltd. All rights reserved.',
          'bn-BD': 'Â© {currentYear} à¦¹à§‹à¦²à¦¸à§‡à¦² à¦¬à¦¿à¦¡à¦¿ à¦²à¦¿à¦®à¦¿à¦Ÿà§‡à¦¡à¥¤ à¦¸à¦°à§à¦¬à¦¸à§à¦¬à¦¤à§à¦¬ à¦¸à¦‚à¦°à¦•à§à¦·à¦¿à¦¤à¥¤',
        },
      },
    },
  },
  {
    key: 'pageMeta:/profile/:profileId',
    description: 'SEO metadata for dynamic user profile pages.',
    value: {
      titleTemplate: {
        'en-US': "{profileName}'s Profile | Wholesale BD",
        'bn-BD': '{profileName}-à¦à¦° à¦ªà§à¦°à§‹à¦«à¦¾à¦‡à¦² | à¦¹à§‹à¦²à¦¸à§‡à¦² à¦¬à¦¿à¦¡à¦¿',
      },
      descriptionTemplate: {
        'en-US':
          'View the public business profile for {profileName} on Wholesale BD.',
        'bn-BD':
          'à¦¹à§‹à¦²à¦¸à§‡à¦² à¦¬à¦¿à¦¡à¦¿-à¦¤à§‡ {profileName}-à¦à¦° à¦ªà¦¾à¦¬à¦²à¦¿à¦• à¦¬à§à¦¯à¦¬à¦¸à¦¾à¦¯à¦¼à¦¿à¦• à¦ªà§à¦°à§‹à¦«à¦¾à¦‡à¦² à¦¦à§‡à¦–à§à¦¨à¥¤',
      },
    },
  },
];


--------------------------------------------------------------------------------
--- FILE: src/metadata/dto/language.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, Length } from 'class-validator';

export class LanguageDto {
  @ApiProperty({
    example: 'fr-FR',
    description: 'The IETF language tag (e.g., en-US, bn-BD).',
  })
  @IsString()
  @IsNotEmpty()
  @Length(2, 10)
  code: string;

  @ApiProperty({
    example: 'FranÃ§ais',
    description: 'The native name of the language.',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/dto/set-default-language.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class SetDefaultLanguageDto {
  @ApiProperty({
    example: 'bn-BD',
    description: 'The language code to set as the new default.',
  })
  @IsString()
  @IsNotEmpty()
  code: string;
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/dto/update-metadata.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsObject, IsOptional, IsString } from 'class-validator';

export class UpdateMetadataDto {
  @ApiProperty({
    description: 'The entire new value object for the metadata key.',
    example: { siteName: 'My Awesome Site', defaultLanguage: 'en-US' },
    type: 'object',
    // --- THE FIX ---
    // This property is required by Swagger when defining a generic object
    // to indicate that it can have arbitrary keys.
    additionalProperties: true,
  })
  @IsObject()
  @IsNotEmpty()
  value: Record<string, unknown>;

  @ApiProperty({
    required: false,
    description: 'An optional internal-facing description for this entry.',
    example: 'Global configuration for the main website.',
  })
  @IsString()
  @IsOptional()
  description?: string;
}


--------------------------------------------------------------------------------
--- FILE: src/metadata/schemas/metadata.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose, { HydratedDocument } from 'mongoose';

export type MetadataDocument = HydratedDocument<Metadata>;

@Schema({ timestamps: true, collection: 'metadatas' })
export class Metadata {
  @Prop({
    required: true,
    unique: true,
    trim: true,
    description:
      'The unique key for the metadata entry (e.g., globalConfig, draft:layoutConfig)',
  })
  key: string;

  @Prop({
    type: mongoose.Schema.Types.Mixed,
    required: true,
    description:
      'The value of the entry, which can be any valid JSON structure.',
  })
  // I'm also tightening this from `any` to `Record<string, unknown>` to match our DTO for full type consistency.
  value: Record<string, unknown>;

  @Prop({
    trim: true,
    description: 'An internal-facing description for administrators.',
  })
  description?: string;

  // --- THE FIX ---
  // These properties are managed by Mongoose's `timestamps` option.
  // We declare them here without @Prop() decorators so TypeScript becomes
  // aware of their existence and their type.
  createdAt: Date;
  updatedAt: Date;
}

export const MetadataSchema = SchemaFactory.createForClass(Metadata);


--------------------------------------------------------------------------------
--- FILE: src/metadata/types/metadata.types.ts ---
--------------------------------------------------------------------------------

// Represents a language entry in the global configuration.
export interface ILanguage {
  code: string;
  name: string;
}

// Represents an object where keys are language codes (e.g., "en-US")
// and values are the translated strings.
export type TMultilingual<T> = Record<string, T>;

// Defines the structure of the 'value' field for the 'globalConfig' document.
export interface IGlobalConfigValue {
  siteName: string;
  defaultLanguage: string;
  availableLanguages: ILanguage[];
  brand: {
    officialName: string;
    tagline: TMultilingual<{ sm: string; md: string; lg: string }>;
    logos: Array<{
      useCase: string;
      path: string;
      alt: TMultilingual<string>;
    }>;
  };
}

// Defines the structure for a generic metadata document stored in the database.
// The `value` can be of a known type or a generic object for pageMeta etc.
export interface IMetadata<T = Record<string, unknown>> {
  key: string;
  value: T;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}


--------------------------------------------------------------------------------
--- FILE: src/orders/orders.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get } from '@nestjs/common';
import { ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import { OrdersService } from './orders.service';
import { OrderResponseDto } from './dto/order-response.dto';

@ApiTags('Orders')
@Controller('orders')
export class OrdersController {
  constructor(private readonly ordersService: OrdersService) {}

  @Get('analytics')
  @ApiOperation({ summary: 'Get aggregated order statistics' })
  @ApiOkResponse({
    description: 'Returns a summary of order counts by status.',
    schema: {
      example: {
        total: 1500,
        pending: 75,
        delivered: 1200,
      },
    },
  })
  async getOrderAnalytics(): Promise<{
    total: number;
    pending: number;
    delivered: number;
  }> {
    return this.ordersService.getAnalytics();
  }

  @Get('count')
  @ApiOperation({ summary: 'Get the total number of orders' })
  @ApiOkResponse({
    description: 'Returns the total count of all orders.',
    schema: { example: { totalOrders: 1500 } },
  })
  async getOrderCount(): Promise<{ totalOrders: number }> {
    const count = await this.ordersService.countAll();
    return { totalOrders: count };
  }

  @Get()
  @ApiOperation({ summary: 'Get a list of all orders' })
  @ApiOkResponse({
    description: 'An array of order records.',
    type: [OrderResponseDto],
  })
  async findAll(): Promise<OrderResponseDto[]> {
    const orders = await this.ordersService.findAll();
    return orders.map((order) => OrderResponseDto.fromOrderDocument(order));
  }
}


--------------------------------------------------------------------------------
--- FILE: src/orders/orders.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
import { Order, OrderSchema } from './schemas/order.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Order.name, schema: OrderSchema }]),
  ],
  controllers: [OrdersController],
  providers: [OrdersService],
})
export class OrdersModule {}


--------------------------------------------------------------------------------
--- FILE: src/orders/orders.service.ts ---
--------------------------------------------------------------------------------

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Order, OrderDocument, OrderStatus } from './schemas/order.schema';

@Injectable()
export class OrdersService {
  constructor(
    @InjectModel(Order.name) private orderModel: Model<OrderDocument>,
  ) {}

  async findAll(): Promise<OrderDocument[]> {
    return this.orderModel.find().exec();
  }

  async countAll(): Promise<number> {
    return this.orderModel.countDocuments().exec();
  }

  // --- NEW, MORE EFFICIENT ANALYTICS METHOD ---
  async getAnalytics(): Promise<{
    total: number;
    pending: number;
    delivered: number;
  }> {
    // Run all counting queries in parallel for maximum efficiency
    const [totalCount, pendingCount, deliveredCount] = await Promise.all([
      this.orderModel.countDocuments().exec(),
      this.orderModel.countDocuments({ status: OrderStatus.PENDING }).exec(),
      this.orderModel.countDocuments({ status: OrderStatus.DELIVERED }).exec(),
    ]);

    return {
      total: totalCount,
      pending: pendingCount,
      delivered: deliveredCount,
    };
  }
}


--------------------------------------------------------------------------------
--- FILE: src/orders/dto/order-response.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import {
  OrderDocument,
  OrderStatus,
  PaymentStatus,
} from '../schemas/order.schema';

class OrderItemDto {
  @ApiProperty({ example: '65f1c5a0ef3e2bde5f269b58' })
  productId: string;

  @ApiProperty({ example: 'High-Quality T-Shirt' })
  productName: string;

  @ApiProperty({ example: 10 })
  quantity: number;

  @ApiProperty({ example: 150.5 })
  pricePerUnit: number;

  @ApiProperty({ example: 1505.0 })
  totalPrice: number;
}

class ShippingAddressDto {
  @ApiProperty({ example: 'Jane Doe' })
  fullName: string;

  @ApiProperty({ example: 'Dhaka' })
  city: string;

  @ApiProperty({ example: 'Dhaka Division' })
  zone: string;
}

export class OrderResponseDto {
  @ApiProperty({ example: '65f1d8a0ef3e2bde5f269c12' })
  _id: string;

  @ApiProperty({ example: 'WBD-20240315-0001' })
  orderNumber: string;

  @ApiProperty({ example: '65f1c4a0ef3e2bde5f269a47' })
  customerId: string;

  @ApiProperty({ example: '65f1c4a0ef3e2bde5f269a49' })
  sellerId: string;

  @ApiProperty({ type: [OrderItemDto] })
  items: OrderItemDto[];

  @ApiProperty({ example: 1655.0 })
  totalAmount: number;

  @ApiProperty()
  shippingAddress: ShippingAddressDto;

  @ApiProperty({ example: OrderStatus.PENDING, enum: OrderStatus })
  status: string;

  @ApiProperty({ example: PaymentStatus.PENDING, enum: PaymentStatus })
  paymentStatus: string;

  @ApiProperty()
  createdAt: Date;

  static fromOrderDocument(orderDoc: OrderDocument): OrderResponseDto {
    const dto = new OrderResponseDto();
    dto._id = orderDoc._id.toString();
    dto.orderNumber = orderDoc.orderNumber;
    dto.customerId = orderDoc.customerId;
    dto.sellerId = orderDoc.sellerId;
    dto.items = orderDoc.items.map((item) => ({
      productId: item.productId,
      productName: item.productName,
      quantity: item.quantity,
      pricePerUnit: item.pricePerUnit,
      totalPrice: item.totalPrice,
    }));
    dto.totalAmount = orderDoc.totalAmount;
    dto.shippingAddress = {
      fullName: orderDoc.shippingAddress.fullName,
      city: orderDoc.shippingAddress.city,
      zone: orderDoc.shippingAddress.zone,
    };
    dto.status = orderDoc.status;
    dto.paymentStatus = orderDoc.paymentStatus;
    dto.createdAt = orderDoc.createdAt;
    return dto;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/orders/schemas/order.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose, { HydratedDocument } from 'mongoose';

export type OrderDocument = HydratedDocument<Order>;

// --- Enums for Type Safety ---
export enum OrderStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  READY_FOR_DISPATCH = 'ready_for_dispatch',
  SHIPPED = 'shipped',
  DELIVERED = 'delivered',
  CANCELLED = 'cancelled',
}

export enum PaymentStatus {
  PENDING = 'pending',
  PAID = 'paid',
  FAILED = 'failed',
  REFUNDED = 'refunded',
}

export enum PaymentMethod {
  CASH_ON_DELIVERY = 'cash_on_delivery',
  BANK_TRANSFER = 'bank_transfer',
  MOBILE_BANKING = 'mobile_banking',
  CARD = 'card',
}

// --- Nested Schemas ---
@Schema({ _id: false })
class OrderItem {
  @Prop({
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true,
  })
  productId: string;

  @Prop({ required: true })
  productName: string;

  @Prop()
  productImage?: string;

  @Prop({ required: true, min: 1 })
  quantity: number;

  @Prop({ required: true })
  pricePerUnit: number;

  @Prop({ required: true })
  totalPrice: number;
}
const OrderItemSchema = SchemaFactory.createForClass(OrderItem);

@Schema({ _id: false })
class ShippingAddress {
  @Prop({ required: true })
  fullName: string;

  @Prop({ required: true })
  phone: string;

  @Prop({ required: true })
  address: string;

  @Prop({ required: true })
  city: string;

  @Prop({ required: true })
  zone: string;

  @Prop()
  postalCode?: string;
}
const ShippingAddressSchema = SchemaFactory.createForClass(ShippingAddress);

// --- Main Order Schema ---
@Schema({ timestamps: true })
export class Order {
  @Prop({ required: true, unique: true })
  orderNumber: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true })
  customerId: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true })
  sellerId: string;

  @Prop({ type: [OrderItemSchema], required: true })
  items: OrderItem[];

  // --- Financials ---
  @Prop({ required: true })
  subtotal: number;

  @Prop({ default: 0 })
  shippingCost: number;

  @Prop({ default: 0 })
  tax: number;

  @Prop({ required: true })
  totalAmount: number;

  // --- Shipping ---
  @Prop({ type: ShippingAddressSchema, required: true })
  shippingAddress: ShippingAddress;

  // --- Status & Payment ---
  @Prop({ type: String, enum: OrderStatus, default: OrderStatus.PENDING })
  status: OrderStatus;

  @Prop({ type: String, enum: PaymentStatus, default: PaymentStatus.PENDING })
  paymentStatus: PaymentStatus;

  @Prop({
    type: String,
    enum: PaymentMethod,
    default: PaymentMethod.CASH_ON_DELIVERY,
  })
  paymentMethod: PaymentMethod;

  @Prop()
  notes?: string;

  // --- Timestamps ---
  @Prop({ type: Date })
  deliveredAt?: Date;

  @Prop({ type: Date })
  cancelledAt?: Date;
  // Add this inside the Order class
  createdAt: Date;
  updatedAt: Date;
}

export const OrderSchema = SchemaFactory.createForClass(Order);


--------------------------------------------------------------------------------
--- FILE: src/products/products.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get } from '@nestjs/common';
import { ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import { ProductsService } from './products.service';
import { ProductResponseDto } from './dto/product-response.dto';

@ApiTags('Products')
@Controller('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get('count')
  @ApiOperation({ summary: 'Get the total number of products' })
  @ApiOkResponse({
    description: 'Returns the total count of products.',
    schema: { example: { totalProducts: 542 } },
  })
  async getProductCount(): Promise<{ totalProducts: number }> {
    const count = await this.productsService.countAll();
    return { totalProducts: count };
  }

  @Get()
  @ApiOperation({ summary: 'Get a list of all products' })
  @ApiOkResponse({
    description: 'An array of product records.',
    type: [ProductResponseDto],
  })
  async findAll(): Promise<ProductResponseDto[]> {
    const products = await this.productsService.findAll();
    return products.map((product) =>
      ProductResponseDto.fromProductDocument(product),
    );
  }
}


--------------------------------------------------------------------------------
--- FILE: src/products/products.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductsController } from './products.controller';
import { ProductsService } from './products.service';
import { Product, ProductSchema } from './schemas/product.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Product.name, schema: ProductSchema }]),
  ],
  controllers: [ProductsController],
  providers: [ProductsService],
})
export class ProductsModule {}


--------------------------------------------------------------------------------
--- FILE: src/products/products.service.ts ---
--------------------------------------------------------------------------------

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product, ProductDocument } from './schemas/product.schema';

@Injectable()
export class ProductsService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<ProductDocument>,
  ) {}

  // The return type is now strongly typed
  async findAll(): Promise<ProductDocument[]> {
    return this.productModel.find().exec();
  }

  // --- NEW METHOD for the counter ---
  async countAll(): Promise<number> {
    return this.productModel.countDocuments().exec();
  }
}


--------------------------------------------------------------------------------
--- FILE: src/products/dto/product-response.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import {
  ProductDocument,
  ProductStatus,
  ProductUnit,
} from '../schemas/product.schema';

class PricingTierDto {
  @ApiProperty({
    example: 1,
    description: 'Minimum quantity for this price tier.',
  })
  minQuantity: number;

  @ApiProperty({
    required: false,
    example: 10,
    description:
      'Maximum quantity for this price tier (optional for the last tier).',
  })
  maxQuantity?: number;

  @ApiProperty({
    example: 99.99,
    description: 'Price per unit within this quantity range.',
  })
  pricePerUnit: number;
}

export class ProductResponseDto {
  @ApiProperty({
    example: '65f1c5a0ef3e2bde5f269b58',
    description: 'Unique identifier for the product.',
  })
  _id: string;

  @ApiProperty({
    example: 'High-Quality T-Shirt',
    description: 'Name of the product.',
  })
  name: string;

  @ApiProperty({
    example: 'A comfortable and durable t-shirt made from 100% cotton.',
    description: 'Detailed description of the product.',
  })
  description: string;

  @ApiProperty({
    type: [String],
    example: ['/images/tshirt1.jpg', '/images/tshirt2.jpg'],
    description: 'Array of URLs for product images.',
  })
  images: string[];

  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a47',
    description: 'ID of the product category.',
  })
  categoryId: string;

  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a48',
    description: 'ID of the zone where the product is available.',
  })
  zoneId: string;

  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a49',
    description: 'ID of the seller who listed the product.',
  })
  sellerId: string;

  @ApiProperty({
    type: [PricingTierDto],
    description: 'Defines different prices for different quantities.',
  })
  pricingTiers: PricingTierDto[];

  @ApiProperty({
    example: 10,
    description:
      'The minimum quantity required to place an order for this product.',
  })
  minimumOrderQuantity: number;

  @ApiProperty({
    example: 500,
    description: 'Current available stock quantity.',
  })
  stockQuantity: number;

  @ApiProperty({
    example: ProductUnit.PIECE,
    enum: ProductUnit,
    description: 'The unit of measurement for the product (e.g., piece, kg).',
  })
  unit: string;

  @ApiProperty({
    required: false,
    example: 'BrandX',
    description: 'The brand name of the product.',
  })
  brand?: string;

  @ApiProperty({
    example: ProductStatus.ACTIVE,
    enum: ProductStatus,
    description: 'The current status of the product listing.',
  })
  status: string;

  @ApiProperty({
    example: 4.5,
    description: 'The average user rating of the product (0-5).',
  })
  rating: number;

  @ApiProperty({
    example: 25,
    description: 'The total number of reviews for the product.',
  })
  reviewCount: number;

  @ApiProperty({ description: 'Timestamp of product creation.' })
  createdAt: Date;

  @ApiProperty({ description: 'Timestamp of last product update.' })
  updatedAt: Date;

  static fromProductDocument(productDoc: ProductDocument): ProductResponseDto {
    const dto = new ProductResponseDto();
    dto._id = productDoc._id.toString();
    dto.name = productDoc.name;
    dto.description = productDoc.description;
    dto.images = productDoc.images;
    dto.categoryId = productDoc.categoryId;
    dto.zoneId = productDoc.zoneId;
    dto.sellerId = productDoc.sellerId;
    dto.pricingTiers = productDoc.pricingTiers;
    dto.minimumOrderQuantity = productDoc.minimumOrderQuantity;
    dto.stockQuantity = productDoc.stockQuantity;
    dto.unit = productDoc.unit;
    dto.brand = productDoc.brand;
    dto.status = productDoc.status;
    dto.rating = productDoc.rating;
    dto.reviewCount = productDoc.reviewCount;
    dto.createdAt = productDoc.createdAt;
    dto.updatedAt = productDoc.updatedAt;
    return dto;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/products/schemas/product.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose, { HydratedDocument } from 'mongoose';

export type ProductDocument = HydratedDocument<Product>;

// --- Enums for Type Safety ---
export enum ProductStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  OUT_OF_STOCK = 'out_of_stock',
}

export enum ProductUnit {
  PIECE = 'piece',
  KG = 'kg',
  SET = 'set',
  BOTTLE = 'bottle',
  PAIR = 'pair',
}

// --- Nested Schema for Pricing Tiers ---
@Schema({ _id: false })
class PricingTier {
  @Prop({ required: true })
  minQuantity: number;

  @Prop()
  maxQuantity?: number; // Optional for the highest tier

  @Prop({ required: true })
  pricePerUnit: number;
}
const PricingTierSchema = SchemaFactory.createForClass(PricingTier);

// --- Main Product Schema ---
@Schema({ timestamps: true })
export class Product {
  @Prop({ required: true, trim: true })
  name: string;

  @Prop({ required: true, trim: true })
  description: string;

  @Prop({ type: [String], default: [] })
  images: string[];

  // --- Relationships ---
  @Prop({
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    required: true,
  })
  categoryId: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'Zone', required: true })
  zoneId: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true })
  sellerId: string;

  // --- Pricing & Inventory ---
  @Prop({ type: [PricingTierSchema], default: [] })
  pricingTiers: PricingTier[];

  @Prop({ required: true })
  minimumOrderQuantity: number;

  @Prop({ default: 0 })
  stockQuantity: number;

  @Prop({ type: String, enum: ProductUnit, required: true })
  unit: ProductUnit;

  // --- Details & Specifications ---
  @Prop()
  brand?: string;

  @Prop()
  model?: string;

  @Prop()
  specifications?: string;

  @Prop()
  sku?: string;

  @Prop()
  weight?: number; // in kg

  @Prop()
  dimensions?: string; // e.g., "10 x 5 x 15 cm"

  // --- Status & Metrics ---
  @Prop({ type: String, enum: ProductStatus, default: ProductStatus.ACTIVE })
  status: ProductStatus;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: 0 })
  viewCount: number;

  @Prop({ default: 0 })
  orderCount: number;

  @Prop({ default: 0, min: 0, max: 5 })
  rating: number;

  @Prop({ default: 0 })
  reviewCount: number;
  // Add this inside the Product class
  // --- Timestamps (For TypeScript) ---
  createdAt: Date;
  updatedAt: Date;
}

export const ProductSchema = SchemaFactory.createForClass(Product);


--------------------------------------------------------------------------------
--- FILE: src/users/users.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get, UseGuards } from '@nestjs/common';
import {
  ApiHeader,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger';
import { UsersService } from './users.service';
import { UserResponseDto } from './dto/user-response.dto';
import { ApiKeyGuard } from '../auth/guards/api-key.guard';

@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get('count')
  @ApiOperation({ summary: 'Get the total number of registered users' })
  @ApiOkResponse({
    description: 'Returns the total count of users.',
    schema: { example: { totalUsers: 125 } },
  })
  async getUserCount(): Promise<{ totalUsers: number }> {
    const count = await this.usersService.countAll();
    return { totalUsers: count };
  }

  @Get()
  @ApiOperation({ summary: 'Get a list of all users (Protected)' })
  @ApiOkResponse({
    description: 'An array of user records.',
    type: [UserResponseDto],
  })
  @ApiUnauthorizedResponse({ description: 'Invalid or missing API Key.' })
  @ApiHeader({
    name: 'x-api-key',
    description: 'The secret API key for access',
    required: true,
  })
  @UseGuards(ApiKeyGuard)
  async findAll(): Promise<UserResponseDto[]> {
    const users = await this.usersService.findAll();
    return users.map((user) => UserResponseDto.fromUserDocument(user));
  }
}


--------------------------------------------------------------------------------
--- FILE: src/users/users.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { User, UserSchema } from './schemas/user.schema';
import { ConfigModule } from '@nestjs/config'; // <-- 1. IMPORT THIS

@Module({
  imports: [
    ConfigModule, // <-- 2. ADD THIS
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}


--------------------------------------------------------------------------------
--- FILE: src/users/users.service.ts ---
--------------------------------------------------------------------------------

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';

@Injectable()
export class UsersService {
  constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}

  async findAll(): Promise<UserDocument[]> {
    return this.userModel.find().exec();
  }

  // --- ADD THIS NEW METHOD ---
  /**
   * Counts all users in the database.
   * @returns A promise that resolves to the total number of users.
   */
  async countAll(): Promise<number> {
    return this.userModel.countDocuments().exec();
  }
}


--------------------------------------------------------------------------------
--- FILE: src/users/dto/user-response.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { UserDocument } from '../schemas/user.schema';

export class UserResponseDto {
  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a47',
    description: 'The unique identifier of the user',
  })
  _id: string;

  @ApiProperty({
    example: 'test@example.com',
    description: 'The email address of the user',
  })
  email: string;

  @ApiProperty({ example: 'John', description: "User's first name" })
  firstName: string;

  @ApiProperty({ example: 'Doe', description: "User's last name" })
  lastName: string;

  @ApiProperty({
    required: false,
    example: '+8801712345678',
    description: "User's phone number",
  })
  phone?: string;

  @ApiProperty({
    required: false,
    description: "URL to the user's profile picture",
  })
  profilePicture?: string;

  @ApiProperty({ required: false, description: "User's physical address" })
  address?: string;

  @ApiProperty({
    required: false,
    example: 'Dhaka',
    description: "User's business zone",
  })
  zone?: string;

  @ApiProperty({
    example: true,
    description: 'Indicates if the user account is active',
  })
  isActive: boolean;

  @ApiProperty({
    example: false,
    description: "Indicates if the user's email has been verified",
  })
  emailVerified: boolean;

  @ApiProperty({
    example: 'seller',
    description: 'The role of the user (e.g., admin, seller, customer)',
  })
  role: string;

  @ApiProperty({
    example: 'pending',
    description: 'KYC (Know Your Customer) verification status',
  })
  kycStatus: string;

  @ApiProperty({
    example: 'approved',
    description: 'Seller application status',
  })
  sellerStatus: string;

  @ApiProperty({
    required: false,
    example: 'Doe Electronics',
    description: "User's business name",
  })
  businessName?: string;

  @ApiProperty({
    example: 85,
    description: 'A calculated score representing user trustworthiness',
  })
  trustScore: number;

  @ApiProperty({
    example: true,
    description: 'Indicates if the user is a trusted seller',
  })
  isTrustedUser: boolean;

  @ApiProperty({ description: 'Timestamp of user creation' })
  createdAt: Date;

  @ApiProperty({ description: 'Timestamp of last user update' })
  updatedAt: Date;

  @ApiProperty({
    required: false,
    description: "Timestamp of the user's last login",
  })
  lastLogin?: Date;

  static fromUserDocument(userDoc: UserDocument): UserResponseDto {
    const dto = new UserResponseDto();
    dto._id = userDoc._id.toString();
    dto.email = userDoc.email;
    dto.firstName = userDoc.firstName;
    dto.lastName = userDoc.lastName;
    dto.phone = userDoc.phone;
    dto.profilePicture = userDoc.profilePicture;
    dto.address = userDoc.address;
    dto.zone = userDoc.zone;
    dto.isActive = userDoc.isActive;
    dto.emailVerified = userDoc.emailVerified;
    dto.role = userDoc.role;
    dto.kycStatus = userDoc.kycStatus;
    dto.sellerStatus = userDoc.sellerStatus;
    dto.businessName = userDoc.businessName;
    dto.trustScore = userDoc.trustScore;
    dto.isTrustedUser = userDoc.isTrustedUser;
    dto.createdAt = userDoc.createdAt;
    dto.updatedAt = userDoc.updatedAt;
    dto.lastLogin = userDoc.lastLogin;
    return dto;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/users/schemas/user.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose, { HydratedDocument } from 'mongoose';

export type UserDocument = HydratedDocument<User>;

// --- Enums for Type Safety ---
export enum UserRole {
  ADMIN = 'admin',
  SELLER = 'seller',
  CUSTOMER = 'customer',
}

export enum KycStatus {
  APPROVED = 'approved',
  PENDING = 'pending',
  REJECTED = 'rejected',
  NOT_STARTED = 'not_started',
}

export enum SellerStatus {
  APPROVED = 'approved',
  PENDING = 'pending',
  REJECTED = 'rejected',
}

// --- Nested Schema for TwoFactorAuth ---
@Schema({ _id: false }) // _id: false prevents Mongoose from creating an _id for this sub-document
class TwoFactorAuth {
  @Prop({ default: false })
  enabled: boolean;

  @Prop({ type: [String], default: [] })
  backupCodes: string[];
}
const TwoFactorAuthSchema = SchemaFactory.createForClass(TwoFactorAuth);

// --- Main User Schema ---
@Schema({ timestamps: true })
export class User {
  // --- Core Identity ---
  @Prop({ required: true, unique: true, lowercase: true, trim: true })
  email: string;

  @Prop({ select: false }) // `select: false` hides the password by default in `find()` queries
  password?: string;

  @Prop({ required: true, trim: true })
  firstName: string;

  @Prop({ required: true, trim: true })
  lastName: string;

  @Prop()
  phone?: string;

  @Prop()
  profilePicture?: string; // For Google/Social logins

  // --- Authentication & Social Login ---
  @Prop({ type: [String], default: [] })
  authProviders: string[];

  @Prop()
  googleId?: string;

  @Prop()
  firebaseUid?: string;

  // --- Location & Contact ---
  @Prop()
  address?: string;

  @Prop()
  zone?: string;

  // --- Status & Roles ---
  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  emailVerified: boolean;

  @Prop({ type: String, enum: UserRole, default: UserRole.CUSTOMER })
  role: UserRole;

  @Prop({ type: String, enum: KycStatus, default: KycStatus.NOT_STARTED })
  kycStatus: KycStatus;

  @Prop({ type: String, enum: SellerStatus, default: SellerStatus.PENDING })
  sellerStatus: SellerStatus;

  // --- Seller-Specific Information ---
  @Prop()
  businessName?: string;

  @Prop()
  businessLicense?: string;

  @Prop()
  businessDescription?: string;

  @Prop({ type: Date })
  sellerAppliedAt?: Date;

  @Prop({ type: Date })
  sellerApprovedAt?: Date;

  // --- Trust & Reputation ---
  @Prop({ default: false })
  isTrustedUser: boolean;

  @Prop({ type: Date })
  trustedUserSince?: Date;

  @Prop({ default: 0 })
  trustScore: number;

  // --- Activity & Engagement ---
  @Prop({ default: 0 })
  reviewCount: number;

  @Prop({ default: 0 })
  submissionCount: number;

  @Prop({ default: 0 })
  helpfulVotesReceived: number;

  @Prop({ type: Date })
  lastLogin?: Date;

  // --- User Preferences & Documents ---
  @Prop({
    type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Broker' }],
    default: [],
  })
  favoriteBrokers: string[]; // Assuming these are references to other collections

  @Prop({
    type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'PropFirm' }],
    default: [],
  })
  favoritePropFirms: string[]; // Assuming these are references to other collections

  @Prop({ type: [String], default: [] })
  kycDocuments: string[]; // Assuming these are URLs to documents

  // --- Security ---
  @Prop({
    type: TwoFactorAuthSchema,
    default: () => ({ enabled: false, backupCodes: [] }),
  })
  twoFactorAuth: TwoFactorAuth;

  // =======================================================================
  // --- ADDED FOR TYPESCRIPT AWARENESS ---
  // These are automatically managed by Mongoose via the `timestamps: true` option,
  // but we need to declare them here for TypeScript to know they exist.
  createdAt: Date;
  updatedAt: Date;
}

export const UserSchema = SchemaFactory.createForClass(User);


--------------------------------------------------------------------------------
--- FILE: src/zones/zones.controller.ts ---
--------------------------------------------------------------------------------

import { Controller, Get } from '@nestjs/common';
import { ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import { ZonesService } from './zones.service';
import { ZoneResponseDto } from './dto/zone-response.dto';

@ApiTags('Zones')
@Controller('zones')
export class ZonesController {
  constructor(private readonly zonesService: ZonesService) {}

  @Get('count')
  @ApiOperation({ summary: 'Get the total number of zones' })
  @ApiOkResponse({
    description: 'Returns the total count of zones.',
    schema: { example: { totalZones: 8 } },
  })
  async getZoneCount(): Promise<{ totalZones: number }> {
    const count = await this.zonesService.countAll();
    return { totalZones: count };
  }

  @Get()
  @ApiOperation({ summary: 'Get a list of all zones' })
  @ApiOkResponse({
    description: 'An array of zone records, sorted by sortOrder.',
    type: [ZoneResponseDto],
  })
  async findAll(): Promise<ZoneResponseDto[]> {
    const zones = await this.zonesService.findAll();
    return zones.map((zone) => ZoneResponseDto.fromZoneDocument(zone));
  }
}


--------------------------------------------------------------------------------
--- FILE: src/zones/zones.module.ts ---
--------------------------------------------------------------------------------

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ZonesController } from './zones.controller';
import { ZonesService } from './zones.service';
import { Zone, ZoneSchema } from './schemas/zone.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Zone.name, schema: ZoneSchema }]),
  ],
  controllers: [ZonesController],
  providers: [ZonesService],
})
export class ZonesModule {}


--------------------------------------------------------------------------------
--- FILE: src/zones/zones.service.ts ---
--------------------------------------------------------------------------------

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Zone, ZoneDocument } from './schemas/zone.schema';

@Injectable()
export class ZonesService {
  constructor(@InjectModel(Zone.name) private zoneModel: Model<ZoneDocument>) {}

  async findAll(): Promise<ZoneDocument[]> {
    return this.zoneModel.find().sort({ sortOrder: 1 }).exec();
  }

  // --- ADD THIS NEW METHOD ---
  async countAll(): Promise<number> {
    return this.zoneModel.countDocuments().exec();
  }
}


--------------------------------------------------------------------------------
--- FILE: src/zones/dto/zone-response.dto.ts ---
--------------------------------------------------------------------------------

import { ApiProperty } from '@nestjs/swagger';
import { ZoneDocument } from '../schemas/zone.schema';

export class ZoneResponseDto {
  @ApiProperty({
    example: '65f1c4a0ef3e2bde5f269a48',
    description: 'Unique identifier for the zone.',
  })
  _id: string;

  @ApiProperty({
    example: 'Dhaka Division',
    description: 'The name of the zone.',
  })
  name: string;

  @ApiProperty({
    example: 'DHK',
    description: 'A short, unique code for the zone.',
  })
  code: string;

  @ApiProperty({
    required: false,
    example: 'Central business and administrative region.',
    description: 'A brief description of the zone.',
  })
  description?: string;

  @ApiProperty({
    example: true,
    description: 'Indicates if the zone is currently active.',
  })
  isActive: boolean;

  @ApiProperty({
    example: 1,
    description: 'The order in which the zone should be displayed.',
  })
  sortOrder: number;

  static fromZoneDocument(zoneDoc: ZoneDocument): ZoneResponseDto {
    const dto = new ZoneResponseDto();
    dto._id = zoneDoc._id.toString();
    dto.name = zoneDoc.name;
    dto.code = zoneDoc.code;
    dto.description = zoneDoc.description;
    dto.isActive = zoneDoc.isActive;
    dto.sortOrder = zoneDoc.sortOrder;
    return dto;
  }
}


--------------------------------------------------------------------------------
--- FILE: src/zones/schemas/zone.schema.ts ---
--------------------------------------------------------------------------------

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';

export type ZoneDocument = HydratedDocument<Zone>;

@Schema({ timestamps: true })
export class Zone {
  @Prop({ required: true, unique: true, trim: true })
  name: string;

  @Prop({ required: true, unique: true, trim: true, uppercase: true })
  code: string;

  @Prop({ trim: true })
  description?: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: 0 })
  sortOrder: number;
  // Add this inside the Zone class
  // For TypeScript awareness of Mongoose's timestamps
  createdAt: Date;
  updatedAt: Date;
}

export const ZoneSchema = SchemaFactory.createForClass(Zone);


